{"version":3,"file":"index.umd.js","sources":["../src/replaceColors/replaceColors.ts","../src/dither/data/diffusion-maps.ts","../src/dither/functions/bayer-matrix.ts","../src/dither/functions/color-helpers.ts","../src/dither/functions/utilities.ts","../src/dither/functions/find-closest-palette-color.ts","../src/dither/dither.ts","../src/index.ts"],"sourcesContent":["const hex = (h) => {\n  return h\n    .replace(\n      /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i,\n      (_, r, g, b) => \"#\" + r + r + g + g + b + b\n    )\n    .substring(1)\n    .match(/.{2}/g)\n    .map((x) => parseInt(x, 16));\n};\n\nexport const replaceColors = (\n  fromCanvas,\n  destCanvas,\n  { originalColors, replaceColors }\n) => {\n  const fromCtx = fromCanvas.getContext(\"2d\");\n  const width = fromCanvas.width;\n  const height = fromCanvas.height;\n\n  const destCtx = destCanvas.getContext(\"2d\");\n\n  const imageData = fromCtx.getImageData(0, 0, width, height);\n  var errorColors = 0;\n\n  const originalColorsRgb = originalColors.map((color) => hex(color));\n  const replaceColorsRgb = replaceColors.map((color) => hex(color));\n\n  for (let i = 0; i < imageData.data.length; i += 4) {\n    // Check if the pixel color matches any of the original colors\n    const colorRgb = originalColorsRgb.find((color) => {\n      return (\n        imageData.data[i] == color[0] &&\n        imageData.data[i + 1] == color[1] &&\n        imageData.data[i + 2] == color[2]\n      );\n    });\n\n    if (colorRgb) {\n      // Find the index of the matched color in the original colors array\n      const index = originalColorsRgb.indexOf(colorRgb);\n      // Get the corresponding color from the replaceColors array\n      const colorMapRgb = replaceColorsRgb[index];\n      if (!colorMapRgb) {\n        return;\n      }\n      imageData.data[i] = colorMapRgb[0];\n      imageData.data[i + 1] = colorMapRgb[1];\n      imageData.data[i + 2] = colorMapRgb[2];\n    } else {\n      errorColors++;\n    }\n  }\n  //});\n  if (errorColors > 0) {\n    console.warn(\n      `replaceColors: ${errorColors} pixels were not replaced. Check if the colors match exactly.`\n    );\n  }\n  // Set size of destination canvas\n  destCanvas.width = width;\n  destCanvas.height = height;\n  destCtx.putImageData(imageData, 0, 0);\n};\n","const maps = {\n  floydSteinberg: () => [\n    { offset: [1, 0], factor: 7 / 16 },\n    { offset: [-1, 1], factor: 3 / 16 },\n    { offset: [0, 1], factor: 5 / 16 },\n    { offset: [1, 1], factor: 1 / 16 },\n  ],\n  falseFloydSteinberg: () => [\n    { offset: [1, 0], factor: 3 / 8 },\n    { offset: [0, 1], factor: 3 / 8 },\n    { offset: [1, 1], factor: 2 / 8 },\n  ],\n  jarvis: () => [\n    { offset: [1, 0], factor: 7 / 48 },\n    { offset: [2, 0], factor: 5 / 48 },\n\n    { offset: [-2, 1], factor: 3 / 48 },\n    { offset: [-1, 1], factor: 5 / 48 },\n    { offset: [0, 1], factor: 7 / 48 },\n    { offset: [1, 1], factor: 5 / 48 },\n    { offset: [2, 1], factor: 3 / 48 },\n\n    { offset: [-2, 2], factor: 1 / 48 },\n    { offset: [-1, 2], factor: 3 / 48 },\n    { offset: [0, 2], factor: 4 / 48 },\n    { offset: [1, 2], factor: 3 / 48 },\n    { offset: [2, 2], factor: 1 / 48 },\n  ],\n  stucki: () => [\n    { offset: [1, 0], factor: 8 / 42 },\n    { offset: [2, 0], factor: 4 / 42 },\n\n    { offset: [-2, 1], factor: 2 / 42 },\n    { offset: [-1, 1], factor: 4 / 42 },\n    { offset: [0, 1], factor: 8 / 42 },\n    { offset: [1, 1], factor: 4 / 42 },\n    { offset: [2, 1], factor: 2 / 42 },\n\n    { offset: [-2, 2], factor: 1 / 42 },\n    { offset: [-1, 2], factor: 2 / 42 },\n    { offset: [0, 2], factor: 4 / 42 },\n    { offset: [1, 2], factor: 2 / 42 },\n    { offset: [2, 2], factor: 1 / 42 },\n  ],\n  burkes: () => [\n    { offset: [1, 0], factor: 8 / 32 },\n    { offset: [2, 0], factor: 4 / 32 },\n\n    { offset: [-2, 1], factor: 2 / 32 },\n    { offset: [-1, 1], factor: 4 / 32 },\n    { offset: [0, 1], factor: 8 / 32 },\n    { offset: [1, 1], factor: 4 / 32 },\n    { offset: [2, 1], factor: 2 / 32 },\n  ],\n  sierra3: () => [\n    { offset: [1, 0], factor: 5 / 32 },\n    { offset: [2, 0], factor: 3 / 32 },\n\n    { offset: [-2, 1], factor: 2 / 32 },\n    { offset: [-1, 1], factor: 4 / 32 },\n    { offset: [0, 1], factor: 5 / 32 },\n    { offset: [1, 1], factor: 4 / 32 },\n    { offset: [2, 1], factor: 2 / 32 },\n\n    { offset: [-1, 2], factor: 2 / 32 },\n    { offset: [0, 2], factor: 3 / 32 },\n    { offset: [1, 2], factor: 2 / 32 },\n  ],\n  sierra2: () => [\n    { offset: [1, 0], factor: 4 / 16 },\n    { offset: [2, 0], factor: 3 / 16 },\n\n    { offset: [-2, 1], factor: 1 / 16 },\n    { offset: [-1, 1], factor: 2 / 16 },\n    { offset: [0, 1], factor: 3 / 16 },\n    { offset: [1, 1], factor: 2 / 16 },\n    { offset: [2, 1], factor: 1 / 16 },\n  ],\n  \"Sierra2-4A\": () => [\n    { offset: [1, 0], factor: 2 / 4 },\n    { offset: [-2, 1], factor: 1 / 4 },\n    { offset: [-1, 1], factor: 1 / 4 },\n  ],\n};\n\nexport default maps;\n","const createBayerMatrix = (size /* [X, Y] */) => {\n  const width = size[0] < 8 ? size[0] : 8;\n  const height = size[1] < 8 ? size[1] : 8;\n\n  const bigMatrix = [\n    [0, 48, 12, 60, 3, 51, 15, 63],\n    [32, 16, 44, 28, 35, 19, 47, 31],\n    [8, 56, 4, 52, 11, 59, 7, 55],\n    [40, 24, 36, 20, 43, 27, 39, 32],\n    [2, 50, 14, 62, 1, 49, 13, 61],\n    [34, 18, 46, 30, 33, 17, 45, 29],\n    [10, 58, 6, 54, 9, 57, 5, 53],\n    [42, 26, 38, 22, 41, 25, 37, 21],\n  ];\n\n  if (width === 8 && height === 8) {\n    // If we're using an 8 by 8 matrix just return the big matrix\n    return bigMatrix;\n  }\n\n  const matrix = [];\n  let currentY = 0;\n  for (currentY; currentY < height; currentY++) {\n    matrix.push([]);\n  }\n\n  matrix.forEach((row, y) => {\n    let x = 0;\n    for (x; x < width; x++) {\n      row.push(bigMatrix[x][y]);\n    }\n  });\n\n  const index = {};\n\n  matrix\n    .flat()\n    .sort((a, b) => a - b)\n    .forEach((n, i) => (index[n] = i));\n\n  matrix.forEach((row, y) => {\n    row.forEach((cell, x) => {\n      matrix[y][x] = index[cell];\n    });\n  });\n\n  // function getPsuedoToroidalDistance (node1, node2 /* [x, y] */) {\n  //     const xDistance = Math.abs(node1[0] - node2[0])\n  //     const yDistance = Math.abs(node1[1] - node2[1])\n  //     return Math.min(xDistance, width - xDistance) + Math.min(yDistance, height - yDistance)\n  // }\n\n  // function findBestUnfilledSlot (previousNode, previousNode2) {\n  //     let bestDistance = 0\n  //     let bestSlot = null\n  //     matrix.forEach((row, y) => {\n  //         row.forEach((cell, x) => {\n  //             if (cell === null) {\n  //                 let distance1 = getPsuedoToroidalDistance(previousNode, [x, y])\n  //                 let distance2 = previousNode2 ? getPsuedoToroidalDistance(previousNode2, [x, y]) : 1\n  //                 let distance = (distance1 * distance2)\n  //                 if (distance > bestDistance) {\n  //                     bestDistance = distance\n  //                     bestSlot = [x, y]\n  //                 }\n  //             }\n  //         })\n  //     })\n  //     return bestSlot\n  // }\n\n  // let previous = null\n  // let previous2 = null\n  // let currentNumber = 0\n  // for (currentNumber; currentNumber < numberOfNodes; currentNumber++) {\n  //     let cellXY = [[currentNumber % width], [currentNumber % height]]\n  //     if (currentNumber === 0) {\n  //         matrix[cellXY[1]][cellXY[0]] = 0\n  //         previous = cellXY\n  //     } else {\n  //         let bestSlot = findBestUnfilledSlot(previous, previous2)\n  //         matrix[bestSlot[1]][bestSlot[0]] = currentNumber\n  //         previous2 = previous\n  //         previous = [bestSlot[0], bestSlot[1]]\n  //     }\n  // }\n\n  return matrix;\n};\n\nexport default createBayerMatrix;\n","export function hexToRgb(hex) {\n  const shorthandRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\n  hex = hex.replace(shorthandRegex, (m, r, g, b) => {\n    return r + r + g + g + b + b;\n  });\n\n  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n  return result\n    ? [\n        parseInt(result[1], 16),\n        parseInt(result[2], 16),\n        parseInt(result[3], 16),\n      ]\n    : null;\n}\n\nconst colorHelper = { hexToRgb };\n\nexport default colorHelper;\n","export function randomInteger(min, max) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\nconst utilities = { randomInteger };\n\nexport default utilities;\n","const findClosestPaletteColor = (pixel, colorPalette) => {\n  const colors = colorPalette.map((color) => {\n    return {\n      distance: distanceInColorSpace(color, pixel),\n      color,\n    };\n  });\n\n  let closestColor;\n  colors.forEach((color) => {\n    if (!closestColor) {\n      closestColor = color;\n    } else {\n      if (color.distance < closestColor.distance) {\n        closestColor = color;\n      }\n    }\n  });\n\n  if (!closestColor.color[3]) {\n    closestColor.color.push(255); // if no alpha value is present add it.\n  }\n\n  return closestColor.color;\n};\n\nconst distanceInColorSpace = (color1, color2) => {\n  // Currenlty ignores alpha\n\n  // Luminosity needs to be accounted for, for better results.\n  // var lumR = .2126,\n  //     lumG = .7152,\n  //     lumB = .0722\n\n  // const max = 255\n\n  // const averageMax = Math.sqrt(lumR * max * max + lumG * max * max + lumB * max * max) // I Dont understand this\n\n  const r = color1[0] - color2[0];\n  const g = color1[1] - color2[1];\n  const b = color1[2] - color2[2];\n\n  const distance = Math.sqrt(r * r + g * g + b * b);\n  return distance;\n};\n\nexport default findClosestPaletteColor;\n","import palettes from \"./data/default-palettes.json\";\nimport diffusionMaps from \"./data/diffusion-maps\";\n//import thresholdMaps from \"./data/threshold-maps.json\";\n\n/* Functions */\nimport bayerMatrix from \"./functions/bayer-matrix\";\nimport colorHelpers from \"./functions/color-helpers\";\n// import colorPaletteFromImage from \"./functions/color-palette-from-image\";\nimport utilities from \"./functions/utilities\";\nimport findClosestPaletteColor from \"./functions/find-closest-palette-color\";\n\nconst defaultOptions = {\n  ditheringType: \"errorDiffusion\",\n\n  errorDiffusionMatrix: \"floydSteinberg\",\n  serpentine: false,\n\n  orderedDitheringType: \"bayer\",\n  orderedDitheringMatrix: [4, 4],\n\n  randomDitheringType: \"blackAndWhite\",\n\n  palette: \"default\",\n\n  sampleColorsFromImage: false,\n  numberOfSampleColors: 10,\n};\n\nconst dither = async (sourceCanvas, canvas, opts) => {\n  if (!sourceCanvas || !canvas) {\n    return;\n  }\n\n  const ctx = sourceCanvas.getContext(\"2d\");\n  const image = ctx.getImageData(0, 0, sourceCanvas.width, sourceCanvas.height);\n\n  const options = { ...defaultOptions, ...opts };\n\n  const width = image.width;\n  let colorPalette = [];\n\n  if (!options.palette || options.sampleColorsFromImage === true) {\n    // colorPalette = colorPaletteFromImage(image, options.numberOfSampleColors);\n  } else {\n    colorPalette = setColorPalette(options.palette);\n  }\n\n  function setPixel(pixelIndex, pixel) {\n    image.data[pixelIndex] = pixel[0];\n    image.data[pixelIndex + 1] = pixel[1];\n    image.data[pixelIndex + 2] = pixel[2];\n    image.data[pixelIndex + 3] = pixel[3];\n  }\n\n  const thresholdMap = bayerMatrix([\n    options.orderedDitheringMatrix[0],\n    options.orderedDitheringMatrix[1],\n  ]);\n\n  let current, newPixel, quantError, oldPixel;\n\n  for (current = 0; current <= image.data.length; current += 4) {\n    const currentPixel = current;\n    oldPixel = getPixelColorValues(currentPixel, image.data);\n\n    if (\n      !options.ditheringType ||\n      options.ditheringType === \"quantizationOnly\"\n    ) {\n      newPixel = findClosestPaletteColor(oldPixel, colorPalette);\n      setPixel(currentPixel, newPixel);\n    }\n\n    if (\n      options.ditheringType === \"random\" &&\n      options.randomDitheringType === \"rgb\"\n    ) {\n      newPixel = randomDitherPixelValue(oldPixel);\n      setPixel(currentPixel, newPixel);\n    }\n\n    if (\n      options.ditheringType === \"random\" &&\n      options.randomDitheringType === \"blackAndWhite\"\n    ) {\n      newPixel = randomDitherBlackAndWhitePixelValue(oldPixel);\n      setPixel(currentPixel, newPixel);\n    }\n\n    if (options.ditheringType === \"ordered\") {\n      const orderedDitherThreshold = 256 / 4;\n      newPixel = orderedDitherPixelValue(\n        oldPixel,\n        pixelXY(currentPixel / 4, width),\n        thresholdMap,\n        orderedDitherThreshold\n      );\n      newPixel = findClosestPaletteColor(newPixel, colorPalette);\n      setPixel(currentPixel, newPixel);\n    }\n\n    const diffusionMap =\n      diffusionMaps[options.errorDiffusionMatrix]() ||\n      diffusionMaps[\"floydSteinberg\"]();\n    if (options.ditheringType === \"errorDiffusion\") {\n      newPixel = findClosestPaletteColor(oldPixel, colorPalette);\n\n      setPixel(currentPixel, newPixel);\n\n      quantError = getQuantError(oldPixel, newPixel);\n\n      diffusionMap.forEach((diffusion) => {\n        const pixelOffset =\n          diffusion.offset[0] * 4 + diffusion.offset[1] * 4 * width;\n        const pixelIndex = currentPixel + pixelOffset;\n        if (!image.data[pixelIndex]) {\n          // Check if pixel exists e.g. on the edges\n          return;\n        }\n        const errorPixel = addQuantError(\n          getPixelColorValues(pixelIndex, image.data),\n          quantError,\n          diffusion.factor\n        );\n        setPixel(pixelIndex, errorPixel);\n      });\n    }\n  }\n\n  return imageDataToCanvas(image, canvas);\n};\n\nconst getPixelColorValues = (pixelIndex, data) => {\n  return [\n    data[pixelIndex],\n    data[pixelIndex + 1],\n    data[pixelIndex + 2],\n    data[pixelIndex + 3],\n  ];\n};\n\nconst getQuantError = (oldPixel, newPixel) => {\n  //const maxValue = 255\n  const quant = oldPixel.map((color, i) => {\n    return color - newPixel[i];\n  });\n\n  return quant;\n};\n\nconst addQuantError = (pixel, quantError, diffusionFactor) => {\n  return pixel.map((color, i) => color + quantError[i] * diffusionFactor);\n};\n\nconst randomDitherPixelValue = (pixel) => {\n  return pixel.map((color) =>\n    color < utilities.randomInteger(0, 255) ? 0 : 255\n  );\n};\n\nconst randomDitherBlackAndWhitePixelValue = (pixel) => {\n  const averageRGB = (pixel[0] + pixel[1] + pixel[2]) / 3;\n  return averageRGB < utilities.randomInteger(0, 255)\n    ? [0, 0, 0, 255]\n    : [255, 255, 255, 255];\n};\n\nconst orderedDitherPixelValue = (\n  pixel,\n  coordinates,\n  thresholdMap,\n  threshold\n) => {\n  const factor =\n    thresholdMap[coordinates[1] % thresholdMap.length][\n      coordinates[0] % thresholdMap[0].length\n    ] /\n    (thresholdMap.length * thresholdMap[0].length);\n  return pixel.map((color) => color + factor * threshold);\n};\n\nconst pixelXY = (index, width) => {\n  return [index % width, Math.floor(index / width)];\n};\n\nconst setColorPalette = (palette) => {\n  const paletteArray =\n    typeof palette === \"string\" ? palettes[palette] : palette;\n  return paletteArray.map((color) => colorHelpers.hexToRgb(color));\n};\n\nconst imageDataToCanvas = (imageData, canvas) => {\n  canvas.width = imageData.width;\n  canvas.height = imageData.height;\n\n  const ctx = canvas.getContext(\"2d\");\n\n  ctx.putImageData(imageData, 0, 0);\n\n  return canvas;\n};\n\nexport default dither;\n","import palettes from \"./dither/data/default-palettes.json\";\nimport deviceColors from \"./dither/data/default-device-colors.json\";\n\n/**\n * Retrieve a named default palette (hex codes).\n * This is used for dithering images to fit the eInk display and uses the real colors of the display.\n */\nexport function getDefaultPalettes(name: string): string[] {\n  const key = name.toLowerCase();\n  return (palettes as Record<string, string[]>)[key] || palettes.default;\n}\n/**\n * Retrieve a named default device color set that is used for displaying the colors on the eInk display.\n */\nexport function getDeviceColors(name: string): string[] {\n  const key = name.toLowerCase();\n  return (\n    (deviceColors as Record<string, string[]>)[key] || deviceColors.default\n  );\n}\n\nexport { replaceColors } from \"./replaceColors/replaceColors\";\n\nexport { default as ditherImage } from \"./dither/dither\";\n"],"names":["hex","h","_","g","b","x","replaceColors","fromCanvas","destCanvas","originalColors","fromCtx","width","height","destCtx","imageData","errorColors","originalColorsRgb","color","replaceColorsRgb","colorRgb","index","colorMapRgb","maps","createBayerMatrix","size","bigMatrix","matrix","currentY","row","y","a","n","i","cell","hexToRgb","shorthandRegex","m","r","result","colorHelper","randomInteger","min","max","utilities","findClosestPaletteColor","pixel","colorPalette","colors","distanceInColorSpace","closestColor","color1","color2","defaultOptions","dither","sourceCanvas","canvas","opts","image","options","setColorPalette","setPixel","pixelIndex","thresholdMap","bayerMatrix","current","newPixel","quantError","oldPixel","currentPixel","getPixelColorValues","randomDitherPixelValue","randomDitherBlackAndWhitePixelValue","orderedDitherPixelValue","pixelXY","diffusionMap","diffusionMaps","getQuantError","diffusion","pixelOffset","errorPixel","addQuantError","imageDataToCanvas","data","diffusionFactor","coordinates","threshold","factor","palette","palettes","colorHelpers","getDefaultPalettes","name","key","getDeviceColors","deviceColors"],"mappings":"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"}