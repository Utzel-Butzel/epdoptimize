{"version":3,"file":"index.es.js","sources":["../src/replaceColors/replaceColors.ts","../src/dither/data/diffusion-maps.ts","../src/dither/functions/bayer-matrix.ts","../src/dither/functions/color-helpers.ts","../src/dither/functions/utilities.ts","../src/dither/functions/find-closest-palette-color.ts","../src/dither/dither.ts","../src/index.ts"],"sourcesContent":["const hex = (h) => {\n  return h\n    .replace(\n      /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i,\n      (_, r, g, b) => \"#\" + r + r + g + g + b + b\n    )\n    .substring(1)\n    .match(/.{2}/g)\n    .map((x) => parseInt(x, 16));\n};\n\nexport const replaceColors = (\n  fromCanvas,\n  destCanvas,\n  { originalColors, replaceColors }\n) => {\n  const fromCtx = fromCanvas.getContext(\"2d\");\n  const width = fromCanvas.width;\n  const height = fromCanvas.height;\n\n  const destCtx = destCanvas.getContext(\"2d\");\n\n  const imageData = fromCtx.getImageData(0, 0, width, height);\n  var errorColors = 0;\n\n  const originalColorsRgb = originalColors.map((color) => hex(color));\n  const replaceColorsRgb = replaceColors.map((color) => hex(color));\n\n  for (let i = 0; i < imageData.data.length; i += 4) {\n    // Check if the pixel color matches any of the original colors\n    const colorRgb = originalColorsRgb.find((color) => {\n      return (\n        imageData.data[i] == color[0] &&\n        imageData.data[i + 1] == color[1] &&\n        imageData.data[i + 2] == color[2]\n      );\n    });\n\n    if (colorRgb) {\n      // Find the index of the matched color in the original colors array\n      const index = originalColorsRgb.indexOf(colorRgb);\n      // Get the corresponding color from the replaceColors array\n      const colorMapRgb = replaceColorsRgb[index];\n      if (!colorMapRgb) {\n        return;\n      }\n      imageData.data[i] = colorMapRgb[0];\n      imageData.data[i + 1] = colorMapRgb[1];\n      imageData.data[i + 2] = colorMapRgb[2];\n    } else {\n      errorColors++;\n    }\n  }\n  //});\n  if (errorColors > 0) {\n    console.warn(\n      `replaceColors: ${errorColors} pixels were not replaced. Check if the colors match exactly.`\n    );\n  }\n  // Set size of destination canvas\n  destCanvas.width = width;\n  destCanvas.height = height;\n  destCtx.putImageData(imageData, 0, 0);\n};\n","const maps = {\n  floydSteinberg: () => [\n    { offset: [1, 0], factor: 7 / 16 },\n    { offset: [-1, 1], factor: 3 / 16 },\n    { offset: [0, 1], factor: 5 / 16 },\n    { offset: [1, 1], factor: 1 / 16 },\n  ],\n  falseFloydSteinberg: () => [\n    { offset: [1, 0], factor: 3 / 8 },\n    { offset: [0, 1], factor: 3 / 8 },\n    { offset: [1, 1], factor: 2 / 8 },\n  ],\n  jarvis: () => [\n    { offset: [1, 0], factor: 7 / 48 },\n    { offset: [2, 0], factor: 5 / 48 },\n\n    { offset: [-2, 1], factor: 3 / 48 },\n    { offset: [-1, 1], factor: 5 / 48 },\n    { offset: [0, 1], factor: 7 / 48 },\n    { offset: [1, 1], factor: 5 / 48 },\n    { offset: [2, 1], factor: 3 / 48 },\n\n    { offset: [-2, 2], factor: 1 / 48 },\n    { offset: [-1, 2], factor: 3 / 48 },\n    { offset: [0, 2], factor: 4 / 48 },\n    { offset: [1, 2], factor: 3 / 48 },\n    { offset: [2, 2], factor: 1 / 48 },\n  ],\n  stucki: () => [\n    { offset: [1, 0], factor: 8 / 42 },\n    { offset: [2, 0], factor: 4 / 42 },\n\n    { offset: [-2, 1], factor: 2 / 42 },\n    { offset: [-1, 1], factor: 4 / 42 },\n    { offset: [0, 1], factor: 8 / 42 },\n    { offset: [1, 1], factor: 4 / 42 },\n    { offset: [2, 1], factor: 2 / 42 },\n\n    { offset: [-2, 2], factor: 1 / 42 },\n    { offset: [-1, 2], factor: 2 / 42 },\n    { offset: [0, 2], factor: 4 / 42 },\n    { offset: [1, 2], factor: 2 / 42 },\n    { offset: [2, 2], factor: 1 / 42 },\n  ],\n  burkes: () => [\n    { offset: [1, 0], factor: 8 / 32 },\n    { offset: [2, 0], factor: 4 / 32 },\n\n    { offset: [-2, 1], factor: 2 / 32 },\n    { offset: [-1, 1], factor: 4 / 32 },\n    { offset: [0, 1], factor: 8 / 32 },\n    { offset: [1, 1], factor: 4 / 32 },\n    { offset: [2, 1], factor: 2 / 32 },\n  ],\n  sierra3: () => [\n    { offset: [1, 0], factor: 5 / 32 },\n    { offset: [2, 0], factor: 3 / 32 },\n\n    { offset: [-2, 1], factor: 2 / 32 },\n    { offset: [-1, 1], factor: 4 / 32 },\n    { offset: [0, 1], factor: 5 / 32 },\n    { offset: [1, 1], factor: 4 / 32 },\n    { offset: [2, 1], factor: 2 / 32 },\n\n    { offset: [-1, 2], factor: 2 / 32 },\n    { offset: [0, 2], factor: 3 / 32 },\n    { offset: [1, 2], factor: 2 / 32 },\n  ],\n  sierra2: () => [\n    { offset: [1, 0], factor: 4 / 16 },\n    { offset: [2, 0], factor: 3 / 16 },\n\n    { offset: [-2, 1], factor: 1 / 16 },\n    { offset: [-1, 1], factor: 2 / 16 },\n    { offset: [0, 1], factor: 3 / 16 },\n    { offset: [1, 1], factor: 2 / 16 },\n    { offset: [2, 1], factor: 1 / 16 },\n  ],\n  \"Sierra2-4A\": () => [\n    { offset: [1, 0], factor: 2 / 4 },\n    { offset: [-2, 1], factor: 1 / 4 },\n    { offset: [-1, 1], factor: 1 / 4 },\n  ],\n};\n\nexport default maps;\n","const createBayerMatrix = (size /* [X, Y] */) => {\n  const width = size[0] < 8 ? size[0] : 8;\n  const height = size[1] < 8 ? size[1] : 8;\n\n  const bigMatrix = [\n    [0, 48, 12, 60, 3, 51, 15, 63],\n    [32, 16, 44, 28, 35, 19, 47, 31],\n    [8, 56, 4, 52, 11, 59, 7, 55],\n    [40, 24, 36, 20, 43, 27, 39, 32],\n    [2, 50, 14, 62, 1, 49, 13, 61],\n    [34, 18, 46, 30, 33, 17, 45, 29],\n    [10, 58, 6, 54, 9, 57, 5, 53],\n    [42, 26, 38, 22, 41, 25, 37, 21],\n  ];\n\n  if (width === 8 && height === 8) {\n    // If we're using an 8 by 8 matrix just return the big matrix\n    return bigMatrix;\n  }\n\n  const matrix = [];\n  let currentY = 0;\n  for (currentY; currentY < height; currentY++) {\n    matrix.push([]);\n  }\n\n  matrix.forEach((row, y) => {\n    let x = 0;\n    for (x; x < width; x++) {\n      row.push(bigMatrix[x][y]);\n    }\n  });\n\n  const index = {};\n\n  matrix\n    .flat()\n    .sort((a, b) => a - b)\n    .forEach((n, i) => (index[n] = i));\n\n  matrix.forEach((row, y) => {\n    row.forEach((cell, x) => {\n      matrix[y][x] = index[cell];\n    });\n  });\n\n  // function getPsuedoToroidalDistance (node1, node2 /* [x, y] */) {\n  //     const xDistance = Math.abs(node1[0] - node2[0])\n  //     const yDistance = Math.abs(node1[1] - node2[1])\n  //     return Math.min(xDistance, width - xDistance) + Math.min(yDistance, height - yDistance)\n  // }\n\n  // function findBestUnfilledSlot (previousNode, previousNode2) {\n  //     let bestDistance = 0\n  //     let bestSlot = null\n  //     matrix.forEach((row, y) => {\n  //         row.forEach((cell, x) => {\n  //             if (cell === null) {\n  //                 let distance1 = getPsuedoToroidalDistance(previousNode, [x, y])\n  //                 let distance2 = previousNode2 ? getPsuedoToroidalDistance(previousNode2, [x, y]) : 1\n  //                 let distance = (distance1 * distance2)\n  //                 if (distance > bestDistance) {\n  //                     bestDistance = distance\n  //                     bestSlot = [x, y]\n  //                 }\n  //             }\n  //         })\n  //     })\n  //     return bestSlot\n  // }\n\n  // let previous = null\n  // let previous2 = null\n  // let currentNumber = 0\n  // for (currentNumber; currentNumber < numberOfNodes; currentNumber++) {\n  //     let cellXY = [[currentNumber % width], [currentNumber % height]]\n  //     if (currentNumber === 0) {\n  //         matrix[cellXY[1]][cellXY[0]] = 0\n  //         previous = cellXY\n  //     } else {\n  //         let bestSlot = findBestUnfilledSlot(previous, previous2)\n  //         matrix[bestSlot[1]][bestSlot[0]] = currentNumber\n  //         previous2 = previous\n  //         previous = [bestSlot[0], bestSlot[1]]\n  //     }\n  // }\n\n  return matrix;\n};\n\nexport default createBayerMatrix;\n","export function hexToRgb(hex) {\n  const shorthandRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\n  hex = hex.replace(shorthandRegex, (m, r, g, b) => {\n    return r + r + g + g + b + b;\n  });\n\n  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n  return result\n    ? [\n        parseInt(result[1], 16),\n        parseInt(result[2], 16),\n        parseInt(result[3], 16),\n      ]\n    : null;\n}\n\nconst colorHelper = { hexToRgb };\n\nexport default colorHelper;\n","export function randomInteger(min, max) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\nconst utilities = { randomInteger };\n\nexport default utilities;\n","const findClosestPaletteColor = (pixel, colorPalette) => {\n  const colors = colorPalette.map((color) => {\n    return {\n      distance: distanceInColorSpace(color, pixel),\n      color,\n    };\n  });\n\n  let closestColor;\n  colors.forEach((color) => {\n    if (!closestColor) {\n      closestColor = color;\n    } else {\n      if (color.distance < closestColor.distance) {\n        closestColor = color;\n      }\n    }\n  });\n\n  if (!closestColor.color[3]) {\n    closestColor.color.push(255); // if no alpha value is present add it.\n  }\n\n  return closestColor.color;\n};\n\nconst distanceInColorSpace = (color1, color2) => {\n  // Currenlty ignores alpha\n\n  // Luminosity needs to be accounted for, for better results.\n  // var lumR = .2126,\n  //     lumG = .7152,\n  //     lumB = .0722\n\n  // const max = 255\n\n  // const averageMax = Math.sqrt(lumR * max * max + lumG * max * max + lumB * max * max) // I Dont understand this\n\n  const r = color1[0] - color2[0];\n  const g = color1[1] - color2[1];\n  const b = color1[2] - color2[2];\n\n  const distance = Math.sqrt(r * r + g * g + b * b);\n  return distance;\n};\n\nexport default findClosestPaletteColor;\n","import palettes from \"./data/default-palettes.json\";\nimport diffusionMaps from \"./data/diffusion-maps\";\n//import thresholdMaps from \"./data/threshold-maps.json\";\n\n/* Functions */\nimport bayerMatrix from \"./functions/bayer-matrix\";\nimport colorHelpers from \"./functions/color-helpers\";\n// import colorPaletteFromImage from \"./functions/color-palette-from-image\";\nimport utilities from \"./functions/utilities\";\nimport findClosestPaletteColor from \"./functions/find-closest-palette-color\";\n\nconst defaultOptions = {\n  ditheringType: \"errorDiffusion\",\n\n  errorDiffusionMatrix: \"floydSteinberg\",\n  serpentine: false,\n\n  orderedDitheringType: \"bayer\",\n  orderedDitheringMatrix: [4, 4],\n\n  randomDitheringType: \"blackAndWhite\",\n\n  palette: \"default\",\n\n  sampleColorsFromImage: false,\n  numberOfSampleColors: 10,\n};\n\nconst dither = async (sourceCanvas, canvas, opts) => {\n  if (!sourceCanvas || !canvas) {\n    return;\n  }\n\n  const ctx = sourceCanvas.getContext(\"2d\");\n  const image = ctx.getImageData(0, 0, sourceCanvas.width, sourceCanvas.height);\n\n  const options = { ...defaultOptions, ...opts };\n\n  const width = image.width;\n  let colorPalette = [];\n\n  if (!options.palette || options.sampleColorsFromImage === true) {\n    // colorPalette = colorPaletteFromImage(image, options.numberOfSampleColors);\n  } else {\n    colorPalette = setColorPalette(options.palette);\n  }\n\n  function setPixel(pixelIndex, pixel) {\n    image.data[pixelIndex] = pixel[0];\n    image.data[pixelIndex + 1] = pixel[1];\n    image.data[pixelIndex + 2] = pixel[2];\n    image.data[pixelIndex + 3] = pixel[3];\n  }\n\n  const thresholdMap = bayerMatrix([\n    options.orderedDitheringMatrix[0],\n    options.orderedDitheringMatrix[1],\n  ]);\n\n  let current, newPixel, quantError, oldPixel;\n\n  for (current = 0; current <= image.data.length; current += 4) {\n    const currentPixel = current;\n    oldPixel = getPixelColorValues(currentPixel, image.data);\n\n    if (\n      !options.ditheringType ||\n      options.ditheringType === \"quantizationOnly\"\n    ) {\n      newPixel = findClosestPaletteColor(oldPixel, colorPalette);\n      setPixel(currentPixel, newPixel);\n    }\n\n    if (\n      options.ditheringType === \"random\" &&\n      options.randomDitheringType === \"rgb\"\n    ) {\n      newPixel = randomDitherPixelValue(oldPixel);\n      setPixel(currentPixel, newPixel);\n    }\n\n    if (\n      options.ditheringType === \"random\" &&\n      options.randomDitheringType === \"blackAndWhite\"\n    ) {\n      newPixel = randomDitherBlackAndWhitePixelValue(oldPixel);\n      setPixel(currentPixel, newPixel);\n    }\n\n    if (options.ditheringType === \"ordered\") {\n      const orderedDitherThreshold = 256 / 4;\n      newPixel = orderedDitherPixelValue(\n        oldPixel,\n        pixelXY(currentPixel / 4, width),\n        thresholdMap,\n        orderedDitherThreshold\n      );\n      newPixel = findClosestPaletteColor(newPixel, colorPalette);\n      setPixel(currentPixel, newPixel);\n    }\n\n    const diffusionMap =\n      diffusionMaps[options.errorDiffusionMatrix]() ||\n      diffusionMaps[\"floydSteinberg\"]();\n    if (options.ditheringType === \"errorDiffusion\") {\n      newPixel = findClosestPaletteColor(oldPixel, colorPalette);\n\n      setPixel(currentPixel, newPixel);\n\n      quantError = getQuantError(oldPixel, newPixel);\n\n      diffusionMap.forEach((diffusion) => {\n        const pixelOffset =\n          diffusion.offset[0] * 4 + diffusion.offset[1] * 4 * width;\n        const pixelIndex = currentPixel + pixelOffset;\n        if (!image.data[pixelIndex]) {\n          // Check if pixel exists e.g. on the edges\n          return;\n        }\n        const errorPixel = addQuantError(\n          getPixelColorValues(pixelIndex, image.data),\n          quantError,\n          diffusion.factor\n        );\n        setPixel(pixelIndex, errorPixel);\n      });\n    }\n  }\n\n  return imageDataToCanvas(image, canvas);\n};\n\nconst getPixelColorValues = (pixelIndex, data) => {\n  return [\n    data[pixelIndex],\n    data[pixelIndex + 1],\n    data[pixelIndex + 2],\n    data[pixelIndex + 3],\n  ];\n};\n\nconst getQuantError = (oldPixel, newPixel) => {\n  //const maxValue = 255\n  const quant = oldPixel.map((color, i) => {\n    return color - newPixel[i];\n  });\n\n  return quant;\n};\n\nconst addQuantError = (pixel, quantError, diffusionFactor) => {\n  return pixel.map((color, i) => color + quantError[i] * diffusionFactor);\n};\n\nconst randomDitherPixelValue = (pixel) => {\n  return pixel.map((color) =>\n    color < utilities.randomInteger(0, 255) ? 0 : 255\n  );\n};\n\nconst randomDitherBlackAndWhitePixelValue = (pixel) => {\n  const averageRGB = (pixel[0] + pixel[1] + pixel[2]) / 3;\n  return averageRGB < utilities.randomInteger(0, 255)\n    ? [0, 0, 0, 255]\n    : [255, 255, 255, 255];\n};\n\nconst orderedDitherPixelValue = (\n  pixel,\n  coordinates,\n  thresholdMap,\n  threshold\n) => {\n  const factor =\n    thresholdMap[coordinates[1] % thresholdMap.length][\n      coordinates[0] % thresholdMap[0].length\n    ] /\n    (thresholdMap.length * thresholdMap[0].length);\n  return pixel.map((color) => color + factor * threshold);\n};\n\nconst pixelXY = (index, width) => {\n  return [index % width, Math.floor(index / width)];\n};\n\nconst setColorPalette = (palette) => {\n  const paletteArray =\n    typeof palette === \"string\" ? palettes[palette] : palette;\n  return paletteArray.map((color) => colorHelpers.hexToRgb(color));\n};\n\nconst imageDataToCanvas = (imageData, canvas) => {\n  canvas.width = imageData.width;\n  canvas.height = imageData.height;\n\n  const ctx = canvas.getContext(\"2d\");\n\n  ctx.putImageData(imageData, 0, 0);\n\n  return canvas;\n};\n\nexport default dither;\n","import palettes from \"./dither/data/default-palettes.json\";\nimport deviceColors from \"./dither/data/default-device-colors.json\";\n\n/**\n * Retrieve a named default palette (hex codes).\n * This is used for dithering images to fit the eInk display and uses the real colors of the display.\n */\nexport function getDefaultPalettes(name: string): string[] {\n  const key = name.toLowerCase();\n  return (palettes as Record<string, string[]>)[key] || palettes.default;\n}\n/**\n * Retrieve a named default device color set that is used for displaying the colors on the eInk display.\n */\nexport function getDeviceColors(name: string): string[] {\n  const key = name.toLowerCase();\n  return (\n    (deviceColors as Record<string, string[]>)[key] || deviceColors.default\n  );\n}\n\nexport { replaceColors } from \"./replaceColors/replaceColors\";\n\nexport { default as ditherImage } from \"./dither/dither\";\n"],"names":["hex","h","_","g","b","x","replaceColors","fromCanvas","destCanvas","originalColors","fromCtx","width","height","destCtx","imageData","errorColors","originalColorsRgb","color","replaceColorsRgb","colorRgb","index","colorMapRgb","maps","createBayerMatrix","size","bigMatrix","matrix","currentY","row","y","a","n","i","cell","hexToRgb","shorthandRegex","m","r","result","colorHelper","randomInteger","min","max","utilities","findClosestPaletteColor","pixel","colorPalette","colors","distanceInColorSpace","closestColor","color1","color2","defaultOptions","dither","sourceCanvas","canvas","opts","image","options","setColorPalette","setPixel","pixelIndex","thresholdMap","bayerMatrix","current","newPixel","quantError","oldPixel","currentPixel","getPixelColorValues","randomDitherPixelValue","randomDitherBlackAndWhitePixelValue","orderedDitherPixelValue","pixelXY","diffusionMap","diffusionMaps","getQuantError","diffusion","pixelOffset","errorPixel","addQuantError","imageDataToCanvas","data","diffusionFactor","coordinates","threshold","factor","palette","palettes","colorHelpers","getDefaultPalettes","name","key","getDeviceColors","deviceColors"],"mappings":"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"}